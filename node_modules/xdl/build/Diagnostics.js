'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDeviceInfoAsync = undefined;

let _uploadLogsAsync = (() => {
  var _ref = _asyncToGenerator(function* (info) {
    let user = yield (_User || _load_User()).default.getCurrentUserAsync();
    let username = user ? user.username : 'anonymous';

    // write info to file
    let expoHome = (_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory();
    let infoJsonFile = new (_jsonFile || _load_jsonFile()).default(_path.default.join(expoHome, 'debug-info.json'));
    yield infoJsonFile.writeAsync(info);

    // copy files to tempDir
    let tempDir = _path.default.join((_Env || _load_Env()).home(), `${username}-diagnostics`);
    let archivePath = _path.default.join(expoHome, 'diagnostics.tar.gz');
    yield (_Utils || _load_Utils()).ncpAsync(expoHome, tempDir, {
      filter: function (filename) {
        if (filename.includes('diagnostics') || filename.includes('starter-app-cache') || filename.includes('android-apk-cache') || filename.includes('ios-simulator-app-cache')) {
          return false;
        } else {
          return true;
        }
      }
    });

    // remove access token
    try {
      let settingsJsonFile = new (_jsonFile || _load_jsonFile()).default(_path.default.join(tempDir, (_UserSettings || _load_UserSettings()).default.SETTINGS_FILE_NAME));
      let settingsJson = yield settingsJsonFile.readAsync();
      settingsJson.accessToken = 'redacted';
      yield settingsJsonFile.writeAsync(settingsJson);
    } catch (e) {
      console.error(e);
    }

    // compress
    yield (0, (_tar || _load_tar()).default)().compress(tempDir, archivePath);
    (_rimraf || _load_rimraf()).default.sync(tempDir);

    // upload
    let file = _fs.default.createReadStream(archivePath);
    let formData = {
      archive: file
    };

    let response = yield (_Api || _load_Api()).default.callMethodAsync('uploadDiagnostics', [{}], 'put', null, { formData });
    return response.url;
  });

  return function _uploadLogsAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

/* eslint-disable prefer-template */
// From http://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript


/* eslint-enable prefer-template */

let getDeviceInfoAsync = exports.getDeviceInfoAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (options = {}) {
    let info = {};

    yield (_Binaries || _load_Binaries()).sourceBashLoginScriptsAsync();
    let whichCommand = process.platform === 'win32' ? 'where' : 'which';

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)('node', ['--version']);
      info.nodeVersion = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)(whichCommand, ['node']);
      info.nodePath = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['--version']);
      info.npmVersion = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)(whichCommand, ['npm']);
      info.npmPath = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    try {
      info.watchmanVersion = yield (_Watchman || _load_Watchman()).unblockAndGetVersionAsync();
    } catch (e) {}

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)(whichCommand, ['watchman']);
      info.watchmanPath = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)('adb', ['version']);
      info.adbVersion = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    try {
      let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)(whichCommand, ['adb']);
      info.adbPath = (_lodash || _load_lodash()).default.trim(result.stdout);
    } catch (e) {}

    info.path = process.env.PATH;
    info.shell = process.env.SHELL;
    info.home = _os.default.homedir();
    info.nvmPath = process.env.NVM_PATH;
    info.lang = process.env.LANG;
    info.dirname = __dirname;
    info.memoryFree = _formatBytes(_os.default.freemem());
    info.memoryTotal = _formatBytes(_os.default.totalmem());
    info.ip = (_ip || _load_ip()).default.address();
    info.hostname = _os.default.hostname();

    // TODO: fix these commands on linux
    if (process.platform === 'darwin') {
      // || process.platform === 'linux') {
      try {
        info.xdeProcesses = (_lodash || _load_lodash()).default.trim(_child_process.default.execSync('pgrep XDE | xargs ps -p').toString());
      } catch (e) {}

      try {
        info.numXdeProcesses = (_lodash || _load_lodash()).default.trim(_child_process.default.execSync('pgrep XDE | wc -l').toString());
      } catch (e) {}

      try {
        info.watchmanProcesses = (_lodash || _load_lodash()).default.trim(_child_process.default.execSync('pgrep watchman | xargs ps -p').toString());
      } catch (e) {}

      try {
        info.numWatchmanProcesses = (_lodash || _load_lodash()).default.trim(_child_process.default.execSync('pgrep watchman | wc -l').toString());
      } catch (e) {}

      try {
        info.ngrokProcesses = (_lodash || _load_lodash()).default.trim(_child_process.default.execSync('pgrep ngrok | xargs ps -p').toString());
      } catch (e) {}

      try {
        info.numNgrokProcesses = (_lodash || _load_lodash()).default.trim(_child_process.default.execSync('pgrep ngrok | wc -l').toString());
      } catch (e) {}
    }

    if (process.platform === 'darwin') {
      // `xcrun` and `xcodebuild` will pop up a dialog if Xcode isn't installed
      if ((_Binaries || _load_Binaries()).isXcodeInstalled()) {
        try {
          let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)('xcrun', ['--version']);
          info.xcrunVersion = (_lodash || _load_lodash()).default.trim(result.stdout);
        } catch (e) {}

        try {
          let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)('xcodebuild', ['-version']);
          info.xcodebuildVersion = (_lodash || _load_lodash()).default.trim(result.stdout);
        } catch (e) {}
      }

      try {
        let result = yield (0, (_spawnAsync || _load_spawnAsync()).default)('launchctl', ['limit']);
        info.launchctlLimit = (_lodash || _load_lodash()).default.trim(result.stdout);
      } catch (e) {}
    }

    // TODO: can probably get rid of these options if we remove Intercom
    if (options.uploadLogs) {
      info.url = yield _uploadLogsAsync(info);
    }

    if (options.limitLengthForIntercom) {
      info = (_lodash || _load_lodash()).default.mapValues(info, function (value) {
        if (value && value.length > 100 && !value.startsWith('http')) {
          return value.substring(0, 100);
        } else {
          return value;
        }
      });
    }

    return info;
  });

  return function getDeviceInfoAsync() {
    return _ref2.apply(this, arguments);
  };
})();

require('instapromise');

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _child_process = _interopRequireDefault(require('child_process'));

var _fs = _interopRequireDefault(require('fs'));

var _ip;

function _load_ip() {
  return _ip = _interopRequireDefault(require('ip'));
}

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@exponent/json-file'));
}

var _os = _interopRequireDefault(require('os'));

var _path = _interopRequireDefault(require('path'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@exponent/spawn-async'));
}

var _tar;

function _load_tar() {
  return _tar = _interopRequireDefault(require('tar.gz'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('./Api'));
}

var _Binaries;

function _load_Binaries() {
  return _Binaries = _interopRequireWildcard(require('./Binaries'));
}

var _Env;

function _load_Env() {
  return _Env = _interopRequireWildcard(require('./Env'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('./User'));
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('./UserSettings'));
}

var _Utils;

function _load_Utils() {
  return _Utils = _interopRequireWildcard(require('./Utils'));
}

var _Watchman;

function _load_Watchman() {
  return _Watchman = _interopRequireWildcard(require('./Watchman'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _formatBytes(bytes) {
  if (bytes >= 1000000000) {
    return (bytes / 1000000000).toFixed(2) + ' GB';
  } else if (bytes >= 1000000) {
    return (bytes / 1000000).toFixed(2) + ' MB';
  } else if (bytes >= 1000) {
    return (bytes / 1000).toFixed(2) + ' KB';
  } else if (bytes > 1) {
    return bytes + ' bytes';
  } else if (bytes === 1) {
    return bytes + '${bytes} byte';
  } else {
    return '0 bytes';
  }
}
//# sourceMappingURL=__sourcemaps__/Diagnostics.js.map
