'use strict';

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _uuid;

function _load_uuid() {
  return _uuid = _interopRequireDefault(require('uuid'));
}

var _ApiV;

function _load_ApiV() {
  return _ApiV = _interopRequireDefault(require('../ApiV2'));
}

var _User;

function _load_User() {
  return _User = require('../User');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const XDL_TEST_CLIENT_ID = 'o0YygTgKhOTdoWj10Yl9nY2P0SMTw38Y';

describe('UserManager', () => {
  let userForTest;
  let userForTestPassword;

  beforeAll(_asyncToGenerator(function* () {
    process.env.__UNSAFE_EXPO_HOME_DIRECTORY = _path.default.join('/', 'tmp', `.expo-${(_uuid || _load_uuid()).default.v1()}`);

    const UserManager = _newTestUserManager();

    const username = `xdl-test-${(_uuid || _load_uuid()).default.v1()}`;
    const password = (_uuid || _load_uuid()).default.v1();

    // Register a new user that we can use for this test run
    const newUser = yield UserManager.registerAsync({
      username,
      password,
      email: `adam+${username}@getexponent.com`,
      givenName: 'XDL',
      familyName: 'Test User'
    });

    userForTest = newUser;
    userForTestPassword = password; // save password so we can use it to login

    yield UserManager.logoutAsync(); // log us out so we're in a clean state for these tests
  }));

  afterAll(_asyncToGenerator(function* () {
    if (process.env.__UNSAFE_EXPO_HOME_DIRECTORY) {
      (_fsExtra || _load_fsExtra()).default.removeSync(process.env.__UNSAFE_EXPO_HOME_DIRECTORY);
    }

    const api = (_ApiV || _load_ApiV()).default.clientForUser(userForTest);
    try {
      yield api.postAsync('auth/deleteUser');
    } catch (e) {
      console.error(e);
    }
  }));

  it('should make available a global, shared UserManager singleton', () => {
    const { default: UserManager } = require('../User');
    expect(UserManager).toBeDefined();
    expect(UserManager.initialize).toBeDefined();
  });

  it('should not have a currently logged in user', _asyncToGenerator(function* () {
    const UserManager = _newTestUserManager();
    try {
      yield UserManager.ensureLoggedInAsync();
    } catch (e) {
      expect(e.message).toEqual('Not logged in');
    }
  }));

  it('should login successfully', _asyncToGenerator(function* () {
    const UserManager = _newTestUserManager();
    yield UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    });

    const user = yield UserManager.getCurrentUserAsync();
    expect(user).not.toBeNull();
    if (!user) {
      return;
    }
    expect(user.username).toBe(userForTest.username);
    expect(user.idToken).not.toBeFalsy();
  }));

  it('should use cached user after first run of getCurrentUserAsync() instead of verifying token with Auth0', _asyncToGenerator(function* () {
    const UserManager = _newTestUserManager();
    yield UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    });

    // Spy on getProfileAsync
    const _getProfileSpy = jest.fn(UserManager._getProfileAsync);
    // $FlowFixMe
    UserManager._getProfileAsync = _getProfileSpy;

    yield UserManager.getCurrentUserAsync();

    expect(_getProfileSpy).not.toHaveBeenCalled();
  }));

  it('should correctly use lock to prevent getting session twice, simulatenously', _asyncToGenerator(function* () {
    const UserManager = _newTestUserManager();
    yield UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    });

    UserManager._currentUser = null;

    // Spy on getProfileAsync
    const _getProfileSpy = jest.fn(UserManager._getProfileAsync);
    // $FlowFixMe
    UserManager._getProfileAsync = _getProfileSpy;

    const users = yield Promise.all([UserManager.getCurrentUserAsync(), UserManager.getCurrentUserAsync()]);

    expect(_getProfileSpy).toHaveBeenCalledTimes(1);

    // This shouldn't have changed, but just double check it
    expect(users[0].idToken).toEqual(users[1].idToken);
    expect(users[0].refreshToken).toEqual(users[1].refreshToken);
  }));

  it('should detect expired token when calling getCurrentUserAsync', _asyncToGenerator(function* () {
    const UserManager = _newTestUserManager();
    // Make sure we have a session
    const initialUser = yield UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    });
    // set the refresh session threshold to a very high value, simulating an expired token
    UserManager.refreshSessionThreshold = 605000;

    // Spy on _auth0RefreshToken
    const _auth0RefreshTokenSpy = jest.fn(UserManager._auth0RefreshToken);
    // $FlowFixMe
    UserManager._auth0RefreshToken = _auth0RefreshTokenSpy;

    const currentUser = yield UserManager.getCurrentUserAsync();
    expect(_auth0RefreshTokenSpy).toBeCalled();
    expect(currentUser.idToken).not.toEqual(initialUser.idToken);
  }));
});

function _newTestUserManager() {
  const UserManager = new (_User || _load_User()).UserManagerInstance();
  UserManager.initialize(XDL_TEST_CLIENT_ID); // XDL Test Client
  return UserManager;
}
//# sourceMappingURL=../__sourcemaps__/__integration_tests__/UserManager-test.js.map
