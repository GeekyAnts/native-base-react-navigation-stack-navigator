'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAsync = undefined;

let _extractWindowsAsync = (() => {
  var _ref = _asyncToGenerator(function* (archive, dir) {
    let dotExpoHomeDirectory = (_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory();
    let tmpDir = _path.default.join(dotExpoHomeDirectory, 'tmp', (_nodeUuid || _load_nodeUuid()).default.v4());
    (_mkdirp || _load_mkdirp()).default.sync(tmpDir);
    let binary = _path.default.join((_Binaries || _load_Binaries()).getBinariesPath(), '7z1602-extra', '7za');
    try {
      yield (0, (_spawnAsync || _load_spawnAsync()).default)(binary, ['x', archive, '-aoa', `-o${tmpDir}`]);
      // We don't know the resulting filename after this step, so
      // just assume the only file in the directory is our .tar file.
      // This should be fine since we created the directory with a random name.
      let files = _fs.default.readdirSync(tmpDir);
      let outputFile = _path.default.resolve(tmpDir, files[0]);
      yield (0, (_spawnAsync || _load_spawnAsync()).default)(binary, ['x', outputFile, '-aoa', `-o${dir}`]);
    } catch (e) {
      console.error(e.message);
      console.error(e.stderr);
      throw e;
    } finally {
      (_rimraf || _load_rimraf()).default.sync(tmpDir);
    }
  });

  return function _extractWindowsAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let extractAsync = exports.extractAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (archive, dir) {
    try {
      if (process.platform === 'win32') {
        yield _extractWindowsAsync(archive, dir);
      } else {
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('tar', ['-xf', archive, '-C', dir], {
          stdio: 'inherit',
          cwd: __dirname
        });
      }
    } catch (e) {
      // tar.gz node module doesn't work consistently with big files, so only
      // use it as a backup.
      console.error(e.message);
      yield (0, (_tar || _load_tar()).default)().extract(archive, dir);
    }
  });

  return function extractAsync(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

var _fs = _interopRequireDefault(require('fs'));

var _tar;

function _load_tar() {
  return _tar = _interopRequireDefault(require('tar.gz'));
}

var _path = _interopRequireDefault(require('path'));

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@exponent/spawn-async'));
}

var _mkdirp;

function _load_mkdirp() {
  return _mkdirp = _interopRequireDefault(require('mkdirp'));
}

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _nodeUuid;

function _load_nodeUuid() {
  return _nodeUuid = _interopRequireDefault(require('node-uuid'));
}

var _Binaries;

function _load_Binaries() {
  return _Binaries = _interopRequireWildcard(require('./Binaries'));
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('./UserSettings'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
//# sourceMappingURL=__sourcemaps__/Extract.js.map
