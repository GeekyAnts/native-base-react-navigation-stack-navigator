{"version":3,"sources":["Utils.js"],"names":["ncpAsync","source","dest","options","Promise","resolve","reject","ncp","err","Semaphore","queue","available","acquire","async","resolver","push","release","length","Error","nextResolver","shift"],"mappings":";;;;;;QAMgBA,Q,GAAAA,Q;;;;AAFhB;AAAA;AAAA;;;;;;AAEO,SAASA,QAAT,CAAkBC,MAAlB,EAAkCC,IAAlC,EAAgDC,UAAe,EAA/D,EAAmE;AACxE,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCC,uCAAIN,MAAJM,EAAYL,IAAZK,EAAkBJ,OAAlBI,EAA4BC,GAAD,IAAS;AAClC,UAAIA,GAAJ,EAAS;AACPF;AACF,OAFA,MAEO;AACLD;AACF;AACD,KANDE;AAOD,GARM,CAAP;AASF;;AAEO,MAAME,SAAN,CAAgB;AAAA;AAAA,SACrBC,KADqB,GACgB,EADhB;AAAA,SAErBC,SAFqB,GAET,CAFS;AAAA;;AAIfC,SAANC,GAAkC;AAAA;;AAAA;AAChC,UAAI,MAAKF,SAAL,GAAiB,CAArB,EAAwB;AACtB,cAAKA,SAAL,IAAkB,CAAlB;AACA,eAAOP,QAAQC,OAARD,CAAgB,IAAhBA,CAAP;AACF;;AAEA;AACA;AACA,aAAO,IAAIA,OAAJ,CAAYU;AAAAA,eAAY,MAAKJ,KAAL,CAAWK,IAAX,CAAgBD,QAAhB,CAAZA;AAAAA,OAAZ,CAAP;AARgC;AASlC;;AAEAE,YAAU;AACR,SAAKL,SAAL,IAAkB,CAAlB;;AAEA,QAAI,KAAKA,SAAL,GAAiB,CAAjB,IAAsB,KAAKD,KAAL,CAAWO,MAAX,GAAoB,CAA9C,EAAiD;AAC/C,YAAM,IAAIC,KAAJ,CAAU,mEAAV,CAAN;AACF,KAFA,MAEO,IAAI,KAAKP,SAAL,KAAmB,CAAnB,IAAwB,KAAKD,KAAL,CAAWO,MAAX,GAAoB,CAAhD,EAAmD;AACxD;AACA;AACA,WAAKN,SAAL,IAAkB,CAAlB;;AAEA,YAAMQ,eAAe,KAAKT,KAAL,CAAWU,KAAX,EAArB;AACA,UAAID,YAAJ,EAAkB;AAChBA,qBAAa,IAAbA;AACF;AACF;AACF;AA9BqB;QAAVV,S,GAAAA,S","file":"../Utils.js","sourcesContent":["/**\n * @flow\n */\n\nimport ncp from 'ncp';\n\nexport function ncpAsync(source: string, dest: string, options: any = {}) {\n  return new Promise((resolve, reject) => {\n    ncp(source, dest, options, (err) => {\n      if (err) {\n        reject();\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexport class Semaphore {\n  queue: Array<(v: boolean) => void> = [];\n  available = 1;\n\n  async acquire(): Promise<boolean> {\n    if (this.available > 0) {\n      this.available -= 1;\n      return Promise.resolve(true);\n    }\n\n    // If there is no permit available, we return a promise that resolves once the semaphore gets\n    // signaled enough times that \"available\" is equal to one.\n    return new Promise(resolver => this.queue.push(resolver));\n  }\n\n  release() {\n    this.available += 1;\n\n    if (this.available > 1 && this.queue.length > 0) {\n      throw new Error('this.available should never be > 0 when there is someone waiting.');\n    } else if (this.available === 1 && this.queue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.available -= 1;\n\n      const nextResolver = this.queue.shift();\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  }\n}\n"],"sourceRoot":"/xdl/src"}