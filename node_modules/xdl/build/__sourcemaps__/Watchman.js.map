{"version":3,"sources":["Watchman.js"],"names":["async","isPlatformSupported","await","Binaries","addToPathAsync","projectRoot","let","result","_unblockAndVersionAsync","watchmanVersion","JSON","parse","_","trim","stdout","version","e","unblockAndGetVersionAsync","cancelObject","isDoneWithVersionCheck","Promise","race","_unblockAsync","_versionAsync","isUnblock","delayAsync","WAIT_FOR_WATCHMAN_VERSION_MS","Error","Analytics","logEvent","process","env","TMPDIR","USER","rimraf","sync","path","join","platform","spawnAsync"],"mappings":"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","file":"../Watchman.js","sourcesContent":["/**\n * @flow\n */\n\nimport _ from 'lodash';\nimport spawnAsync from '@exponent/spawn-async';\nimport delayAsync from 'delay-async';\nimport rimraf from 'rimraf';\nimport path from 'path';\n\nimport * as Analytics from './Analytics';\nimport * as Binaries from './Binaries';\n\nconst WAIT_FOR_WATCHMAN_VERSION_MS = 3000;\n\nexport function isPlatformSupported() {\n  return process.platform === 'darwin';\n}\n\nexport async function addToPathAsync() {\n  if (!isPlatformSupported()) {\n    return;\n  }\n\n  await Binaries.addToPathAsync('watchman');\n}\n\nexport async function unblockAndGetVersionAsync(projectRoot?: string) {\n  if (!isPlatformSupported()) {\n    return null;\n  }\n\n  try {\n    // `watchman version` returns:\n    // {\n    //  \"version\": \"4.7.0\"\n    // }\n    let result = await _unblockAndVersionAsync(projectRoot);\n    let watchmanVersion = JSON.parse(_.trim(result.stdout)).version;\n    return watchmanVersion;\n  } catch (e) {\n    // TODO: Maybe check to make sure this is ENOENT (which means watchman isn't installed)\n    // We might want to report other errors\n    return null;\n  }\n}\n\nasync function _unblockAndVersionAsync(projectRoot?: string) {\n  let cancelObject = {\n    isDoneWithVersionCheck: false,\n  };\n\n  let result = await Promise.race([\n    _unblockAsync(projectRoot, cancelObject),\n    _versionAsync(cancelObject),\n  ]);\n\n  if (result.isUnblock) {\n    result = await Promise.race([\n      _versionAsync(),\n      async () => {\n        await delayAsync(WAIT_FOR_WATCHMAN_VERSION_MS);\n        throw new Error(`\\`watchman version\\` failed even after \\`launchctl unload\\``);\n      },\n    ]);\n    Analytics.logEvent('version after launchctl unload');\n    return result;\n  } else {\n    return result;\n  }\n}\n\nasync function _unblockAsync(projectRoot?: string, cancelObject) {\n  await delayAsync(WAIT_FOR_WATCHMAN_VERSION_MS);\n\n  if (!cancelObject.isDoneWithVersionCheck) {\n    Analytics.logEvent('launchctl unload');\n    if (process.env.TMPDIR && process.env.USER) {\n      // XDL's copy of watchman:\n      rimraf.sync(path.join(process.env.TMPDIR, `${process.env.USER}-state`));\n      // homebrew's watchman:\n      rimraf.sync(`/usr/local/var/run/watchman/${process.env.USER}-state`);\n    }\n    if (process.platform === 'darwin') {\n      await spawnAsync('launchctl', ['unload', '-F', '~/Library/LaunchAgents/com.github.facebook.watchman.plist']);\n    }\n    if (projectRoot) {\n      await spawnAsync('watchman', ['watch-del', projectRoot]);\n      await spawnAsync('watchman', ['watch-project', projectRoot]);\n    }\n  }\n\n  return {\n    isUnblock: true,\n  };\n}\n\nasync function _versionAsync(cancelObject) {\n  let result = await spawnAsync('watchman', ['version']);\n\n  if (cancelObject) {\n    cancelObject.isDoneWithVersionCheck = true;\n  }\n\n  return result;\n}\n"],"sourceRoot":"/xdl/src"}