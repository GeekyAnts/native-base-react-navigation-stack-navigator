// Copyright 2015-present 650 Industries. All rights reserved.

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderPodfileAsync = exports.renderExponentViewPodspecAsync = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 *  @param pathToTemplate path to template Podfile
 *  @param pathToOutput path to render final Podfile
 *  @param moreSubstitutions dictionary of additional substitution keys and values to replace
 *         in the template, such as: TARGET_NAME, EXPONENT_ROOT_PATH, REACT_NATIVE_PATH
 */
let renderPodfileAsync = (() => {
  var _ref = _asyncToGenerator(function* (pathToTemplate, pathToOutput, moreSubstitutions, sdkVersion = 'UNVERSIONED') {
    if (!moreSubstitutions) {
      moreSubstitutions = {};
    }
    let templatesDirectory = _path.default.dirname(pathToTemplate);
    let templateString = yield _fs.default.promise.readFile(pathToTemplate, 'utf8');

    let reactNativePath = moreSubstitutions.REACT_NATIVE_PATH;
    let rnDependencyOptions;
    if (reactNativePath) {
      rnDependencyOptions = { reactNativePath };
    } else {
      rnDependencyOptions = {};
    }

    let versionedDependencies = yield renderVersionedReactNativeDependenciesAsync(templatesDirectory);
    let versionedPostinstalls = yield renderVersionedReactNativePostinstallsAsync(templatesDirectory);
    let podDependencies = yield renderPodDependenciesAsync(_path.default.join(templatesDirectory, 'dependencies.json'), { isPodfile: true });

    let substitutions = _extends({
      EXPONENT_CLIENT_DEPS: podDependencies,
      PODFILE_UNVERSIONED_RN_DEPENDENCY: renderUnversionedReactNativeDependency(rnDependencyOptions, sdkVersion),
      PODFILE_UNVERSIONED_POSTINSTALL: renderUnversionedPostinstall(),
      PODFILE_DETACHED_POSTINSTALL: renderDetachedPostinstall(sdkVersion),
      PODFILE_VERSIONED_RN_DEPENDENCIES: versionedDependencies,
      PODFILE_VERSIONED_POSTINSTALLS: versionedPostinstalls,
      PODFILE_TEST_TARGET: renderPodfileTestTarget(reactNativePath)
    }, moreSubstitutions);

    let result = templateString;
    for (let key in substitutions) {
      if (substitutions.hasOwnProperty(key)) {
        let replacement = substitutions[key];
        result = result.replace(new RegExp(`\\\$\\\{${key}\\\}`, 'g'), replacement);
      }
    }

    yield _fs.default.promise.writeFile(pathToOutput, result);
  });

  return function renderPodfileAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

let renderExponentViewPodspecAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (pathToTemplate, pathToOutput, moreSubstitutions) {
    let templatesDirectory = _path.default.dirname(pathToTemplate);
    let templateString = yield _fs.default.promise.readFile(pathToTemplate, 'utf8');
    let dependencies = yield renderPodDependenciesAsync(_path.default.join(templatesDirectory, 'dependencies.json'), { isPodfile: false });
    let result = templateString.replace(/\$\{IOS_EXPONENT_VIEW_DEPS\}/g, dependencies);
    if (moreSubstitutions && moreSubstitutions.IOS_EXPONENT_CLIENT_VERSION) {
      result = result.replace(/\$\{IOS_EXPONENT_CLIENT_VERSION\}/g, moreSubstitutions.IOS_EXPONENT_CLIENT_VERSION);
    }

    yield _fs.default.promise.writeFile(pathToOutput, result);
  });

  return function renderExponentViewPodspecAsync(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

let renderVersionedReactNativeDependenciesAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (templatesDirectory) {
    // TODO: write these files with versioning script
    return concatTemplateFilesInDirectoryAsync(_path.default.join(templatesDirectory, 'versioned-react-native', 'dependencies'));
  });

  return function renderVersionedReactNativeDependenciesAsync(_x7) {
    return _ref3.apply(this, arguments);
  };
})();

let renderVersionedReactNativePostinstallsAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (templatesDirectory) {
    // TODO: write these files with versioning script
    return concatTemplateFilesInDirectoryAsync(_path.default.join(templatesDirectory, 'versioned-react-native', 'postinstalls'));
  });

  return function renderVersionedReactNativePostinstallsAsync(_x8) {
    return _ref4.apply(this, arguments);
  };
})();

let concatTemplateFilesInDirectoryAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (directory) {
    let templateFilenames = yield (_glob || _load_glob()).default.promise(_path.default.join(directory, '*.rb'));
    let templateStrings = [];
    yield Promise.all(templateFilenames.map((() => {
      var _ref6 = _asyncToGenerator(function* (filename) {
        let templateString = yield _fs.default.promise.readFile(filename, 'utf8');
        if (templateString) {
          templateStrings.push(templateString);
        }
      });

      return function (_x10) {
        return _ref6.apply(this, arguments);
      };
    })()));
    return templateStrings.join('\n');
  });

  return function concatTemplateFilesInDirectoryAsync(_x9) {
    return _ref5.apply(this, arguments);
  };
})();

let renderPodDependenciesAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (dependenciesConfigPath, options) {
    let dependencies = yield new (_jsonFile || _load_jsonFile()).default(dependenciesConfigPath).readAsync();
    let type = options.isPodfile ? 'pod' : 's.dependency';
    let depsStrings = dependencies.map(function (dependency) {
      return `  ${type} '${dependency.name}', '${dependency.version}'`;
    });
    return depsStrings.join('\n');
  });

  return function renderPodDependenciesAsync(_x11, _x12) {
    return _ref7.apply(this, arguments);
  };
})();

var _fs = _interopRequireDefault(require('fs'));

var _glob;

function _load_glob() {
  return _glob = _interopRequireDefault(require('glob'));
}

var _indentString;

function _load_indentString() {
  return _indentString = _interopRequireDefault(require('indent-string'));
}

require('instapromise');

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@exponent/json-file'));
}

var _path = _interopRequireDefault(require('path'));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function renderUnversionedReactNativeDependency(options, sdkVersion) {
  if (sdkVersion === '14.0.0') {
    return (0, (_indentString || _load_indentString()).default)(`
${renderUnversionedReactDependency(options)}
`, 2);
  } else {
    return (0, (_indentString || _load_indentString()).default)(`
${renderUnversionedReactDependency(options)}
${renderUnversionedYogaDependency(options)}
`, 2);
  }
}

function renderUnversionedReactDependency(options) {
  let attributes;
  if (options.reactNativePath) {
    attributes = {
      path: options.reactNativePath
    };
  } else {
    throw new Error(`Unsupported options for RN dependency: ${options}`);
  }

  attributes.subspecs = ['Core', 'ART', 'RCTActionSheet', 'RCTAnimation', 'RCTCameraRoll', 'RCTGeolocation', 'RCTImage', 'RCTNetwork', 'RCTText', 'RCTVibration', 'RCTWebSocket'];

  return `pod 'React',
${(0, (_indentString || _load_indentString()).default)(renderDependencyAttributes(attributes), 2)}`;
}

function renderUnversionedYogaDependency(options) {
  let attributes;
  if (options.reactNativePath) {
    attributes = {
      path: _path.default.join(options.reactNativePath, 'ReactCommon', 'yoga')
    };
  } else {
    throw new Error(`Unsupported options for Yoga dependency: ${options}`);
  }
  return `pod 'Yoga',
${(0, (_indentString || _load_indentString()).default)(renderDependencyAttributes(attributes), 2)}`;
}

function renderDependencyAttributes(attributes) {
  let attributesStrings = [];
  for (let key of Object.keys(attributes)) {
    let value = JSON.stringify(attributes[key], null, 2);
    attributesStrings.push(`:${key} => ${value}`);
  }
  return attributesStrings.join(',\n');
}

function renderDetachedPostinstall(sdkVersion) {
  let podName = sdkVersion === '14.0.0' ? 'ExponentView' : 'ExpoKit';

  let podsRootSub = "${PODS_ROOT}";
  return `
    if target.pod_name == '${podName}'
      target.native_target.build_configurations.each do |config|
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)']
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'EX_DETACHED=1'
        # needed for GoogleMaps 2.x
        config.build_settings['FRAMEWORK_SEARCH_PATHS'] ||= []
        config.build_settings['FRAMEWORK_SEARCH_PATHS'] << '${podsRootSub}/GoogleMaps/Base/Frameworks'
        config.build_settings['FRAMEWORK_SEARCH_PATHS'] << '${podsRootSub}/GoogleMaps/Maps/Frameworks'
      end
    end
`;
}

function renderUnversionedPostinstall() {
  return `
    # Build React Native with RCT_DEV enabled
    next unless target.pod_name == 'React'
    target.native_target.build_configurations.each do |config|
      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)']
      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'RCT_DEV=1'
    end
`;
}

function renderPodfileTestTarget(reactNativePath) {
  return `
  # if you run into problems pre-downloading this, rm Pods/Local\ Podspecs/RCTTest.podspec.json
  target 'ExponentIntegrationTests' do
    inherit! :search_paths
    pod 'RCTTest', :podspec => './RCTTest.podspec', :path => '${reactNativePath}'
  end
`;
}

exports.renderExponentViewPodspecAsync = renderExponentViewPodspecAsync;
exports.renderPodfileAsync = renderPodfileAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosPodsTools.js.map
