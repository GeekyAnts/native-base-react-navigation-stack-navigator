{"version":3,"sources":["../../src/connectStyle.js"],"names":["_","themeCache","throwConnectStyleError","errorMessage","componentDisplayName","Error","getTheme","context","theme","getDefaultTheme","isStyleVariant","propertyName","test","isChildStyle","getConcreteStyle","style","pickBy","value","key","componentStyleName","componentStyle","mapPropsToStyleNames","options","getComponentDisplayName","WrappedComponent","displayName","name","wrapWithStyledComponent","isPlainObject","isString","StyledComponent","props","styleNames","getStyleNames","finalStyle","getFinalStyle","setWrappedInstance","bind","resolveConnectedComponentStyle","state","addedProps","resolveAddedProps","resolvedStyle","parentPath","getOrSetStylesInCache","resolveStyle","merge","styleNamesArr","map","remove","index","getParentPath","nextProps","nextContext","shouldRebuildStyle","setState","nativeProps","wrappedInstance","setNativeProps","component","_root","isEqual","styleName","hasStyleNameChanged","split","uniq","withRef","ref","path","join","Object","keys","length","parentStyle","themeStyle","createComponentStyle","resolveStyleNames","Component","contextTypes","array","childContextTypes","propTypes","object","string","virtual","bool","defaultProps"],"mappings":"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","file":"connectStyle.js","sourcesContent":["import React, { PropTypes } from 'react';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\nimport normalizeStyle from './StyleNormalizer/normalizeStyle';\n\nimport Theme, { ThemeShape } from './Theme';\nimport { resolveComponentStyle } from './resolveComponentStyle';\n\nconst themeCache = {};\n\n/**\n * Formats and throws an error when connecting component style with the theme.\n *\n * @param errorMessage The error message.\n * @param componentDisplayName The name of the component that is being connected.\n */\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\n  throw Error(`${errorMessage} - when connecting ${componentDisplayName} component to style.`);\n}\n\n/**\n * Returns the theme object from the provided context,\n * or an empty theme if the context doesn't contain a theme.\n *\n * @param context The React component context.\n * @returns {Theme} The Theme object.\n */\nfunction getTheme(context) {\n  // Fallback to a default theme if the component isn't\n  // rendered in a StyleProvider.\n  return context.theme || Theme.getDefaultTheme();\n}\n\n/**\n * Matches any style properties that represent component style variants.\n * Those styles can be applied to the component by using the styleName\n * prop. All style variant property names must start with a single '.'\n * character, e.g., '.variant'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\n */\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\n/**\n * Matches any style properties that represent style rules that target the\n * component children. Those styles can have two formats, they can either\n * target the components by component name ('shoutem.ui.Text'), or by component\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\n * component name, those styles can also target any component by using the\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\n * that they have to contain a '.' character in their name or be a '*'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a child style, false otherwise.\n */\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\nfunction getConcreteStyle(style) {\n  return _.pickBy(style, (value, key) => {\n    return !isStyleVariant(key) && !isChildStyle(key);\n  })\n}\n\n/**\n * Resolves the final component style by using the theme style, if available and\n * merging it with the style provided directly through the style prop, and style\n * variants applied through the styleName prop.\n *\n * @param componentStyleName The component name that will be used\n * to target this component in style rules.\n * @param componentStyle The default component style.\n * @param mapPropsToStyleNames Pure function to customize styleNames depending on props.\n * @param options The additional connectStyle options\n * @param options.virtual The default value of the virtual prop\n * @param options.withRef Create component ref with addedProps; if true, ref name is wrappedInstance\n * @returns {StyledComponent} The new component that will handle\n * the styling of the wrapped component.\n */\nexport default (componentStyleName, componentStyle = {}, mapPropsToStyleNames, options = {}) => {\n  function getComponentDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  }\n\n  return function wrapWithStyledComponent(WrappedComponent) {\n    const componentDisplayName = getComponentDisplayName(WrappedComponent);\n\n    if (!_.isPlainObject(componentStyle)) {\n      throwConnectStyleError(\n        'Component style must be plain object',\n        componentDisplayName\n      );\n    }\n\n    if (!_.isString(componentStyleName)) {\n      throwConnectStyleError(\n        'Component Style Name must be string',\n        componentDisplayName\n      );\n    }\n\n    class StyledComponent extends React.Component {\n      static contextTypes = {\n        theme: ThemeShape,\n        // The style inherited from the parent\n        // parentStyle: PropTypes.object,\n        parentPath: PropTypes.array,\n      };\n\n      static childContextTypes = {\n        // Provide the parent style to child components\n        // parentStyle: PropTypes.object,\n        // resolveStyle: PropTypes.func,\n        parentPath: PropTypes.array,\n      };\n\n      static propTypes = {\n        // Element style that overrides any other style of the component\n        style: PropTypes.object,\n        // The style variant names to apply to this component,\n        // multiple variants may be separated with a space character\n        styleName: PropTypes.string,\n        // Virtual elements will propagate the parent\n        // style to their children, i.e., the children\n        // will behave as they are placed directly below\n        // the parent of a virtual element.\n        virtual: PropTypes.bool,\n      };\n\n      static defaultProps = {\n        virtual: options.virtual,\n      };\n\n      static displayName = `Styled(${componentDisplayName})`;\n      static WrappedComponent = WrappedComponent;\n\n      constructor(props, context) {\n        super(props, context);\n        // console.log(context.parentPath);\n        const styleNames = this.getStyleNames(props);\n        const style = props.style;\n        \n        const finalStyle = this.getFinalStyle(props, context, style, styleNames);\n\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\n        this.resolveConnectedComponentStyle = this.resolveConnectedComponentStyle.bind(this);\n        this.state = {\n          style: finalStyle,\n          // AddedProps are additional WrappedComponent props\n          // Usually they are set trough alternative ways,\n          // such as theme style, or trough options\n          addedProps: this.resolveAddedProps(),\n          styleNames,\n        };\n      }\n\n      getFinalStyle(props, context, style, styleNames) {\n        let resolvedStyle = {};\n        if(context.parentPath) {\n          resolvedStyle = this.getOrSetStylesInCache(context, props, styleNames, [...context.parentPath, componentStyleName, ...styleNames]);\n        } else {\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\n          themeCache[componentStyleName] = resolvedStyle;\n        }\n\n        return getConcreteStyle(_.merge({}, resolvedStyle, style));\n      }\n\n      getStyleNames(props) {\n        const styleNamesArr = _.map(props, (value, key) => {\n          if(typeof value !== 'object' && value === true) {\n            return '.' + key;\n          } else {\n            return false;\n          }\n        });\n        _.remove(styleNamesArr, (value, index) => {\n          return value === false;\n        })\n\n        return styleNamesArr;\n      }\n\n      getParentPath() {\n        if(!this.context.parentPath) {\n          return [componentStyleName];\n        } else {\n          return [...this.context.parentPath, componentStyleName, ...this.getStyleNames(this.props)];\n        }\n      }\n\n      getChildContext() {\n        return {\n          // parentStyle: this.props.virtual ?\n          //   this.context.parentStyle :\n          //   this.state.childrenStyle,\n          // resolveStyle: this.resolveConnectedComponentStyle,\n          parentPath: this.getParentPath()\n        };\n      }\n\n      componentWillReceiveProps(nextProps, nextContext) {\n        const styleNames = this.getStyleNames(nextProps);\n        const style = nextProps.style;\n        if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\n\n          const finalStyle = this.getFinalStyle(nextProps, nextContext, style, styleNames);\n\n          this.setState({\n            style: finalStyle,\n            // childrenStyle: resolvedStyle.childrenStyle,\n            styleNames,\n          });\n        }\n      }\n\n      setNativeProps(nativeProps) {\n        if (this.wrappedInstance.setNativeProps) {\n          this.wrappedInstance.setNativeProps(nativeProps);\n        }\n      }\n\n      setWrappedInstance(component) {\n        if(component && component._root) {\n          this._root = component._root;\n        } else {\n          this._root = component;\n        }\n      }\n\n      hasStyleNameChanged(nextProps, styleNames) {\n        return mapPropsToStyleNames && this.props !== nextProps &&\n          // Even though props did change here,\n          // it doesn't necessary means changed props are those which affect styleName\n          !_.isEqual(this.state.styleNames, styleNames);\n      }\n\n      shouldRebuildStyle(nextProps, nextContext, styleNames) {\n        return (nextProps.style !== this.props.style) ||\n          (nextProps.styleName !== this.props.styleName) ||\n          (nextContext.theme !== this.context.theme) ||\n          !_.isEqual(nextContext.parentPath, this.context.parentPath) ||\n          (this.hasStyleNameChanged(nextProps, styleNames));\n      }\n\n      resolveStyleNames(props) {\n        const { styleName } = props;\n        const styleNames = styleName ? styleName.split(/\\s/g) : [];\n\n        if (!mapPropsToStyleNames) {\n          return styleNames;\n        }\n\n        // We only want to keep the unique style names\n        return _.uniq(mapPropsToStyleNames(styleNames, props));\n      }\n\n      resolveAddedProps() {\n        const addedProps = {};\n        if (options.withRef) {\n          addedProps.ref = 'wrappedInstance';\n        }\n        return addedProps;\n      }\n\n      getOrSetStylesInCache(context, props, styleNames, path) {\n        if(themeCache && themeCache[path.join('>')]) {\n          // console.log('**************');\n          \n          return themeCache[path.join('>')];\n        } else {\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\n          if(Object.keys(themeCache).length < 10000) {\n            themeCache[path.join('>')] = resolvedStyle;\n          }\n          return resolvedStyle;\n        }\n      }\n\n      resolveStyle(context, props, styleNames) {\n        let parentStyle = {};\n\n        const theme = getTheme(context);\n        const themeStyle = theme.createComponentStyle(componentStyleName, componentStyle);\n\n        if(context.parentPath) {\n          parentStyle = themeCache[context.parentPath.join('>')]\n        } else {\n          parentStyle = resolveComponentStyle(\n            componentStyleName,\n            styleNames,\n            themeStyle,\n            parentStyle\n          );\n        }\n\n        return resolveComponentStyle(\n          componentStyleName,\n          styleNames,\n          themeStyle,\n          parentStyle\n        );\n      }\n\n      /**\n       * A helper function provided to child components that enables\n       * them to resolve their style for any set of prop values.\n       *\n       * @param props The component props to use to resolve the style values.\n       * @returns {*} The resolved component style.\n       */\n      resolveConnectedComponentStyle(props) {\n        const styleNames = this.resolveStyleNames(props);\n        return this.resolveStyle(this.context, props, styleNames).componentStyle;\n      }\n\n      render() {\n        // console.log('themeCache', themeCache);\n\n        // if(componentStyleName == 'NativeBase.Text') {\n        //   console.log(this.state.style);\n        //   console.log(themeCache);\n        // }\n        \n        const { addedProps, style } = this.state;\n        return (\n          <WrappedComponent\n            {...this.props}\n            {...addedProps}\n            style={style}\n            ref={this.setWrappedInstance}\n          />);\n      }\n    }\n\n    return hoistStatics(StyledComponent, WrappedComponent);\n  };\n};\n"]}